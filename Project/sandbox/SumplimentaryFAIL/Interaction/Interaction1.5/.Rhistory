xlab('Model')+
ylab('Count')
TempPlot
View(LetsGO)
dev.o
dev.off
dev.off()
require(viridis)
LetsGO <- data.frame(Subset = 1:max(DF$ID),
Temp = 0,
Bestmodel = Best_model$BestModelAIC,
stringsAsFactors = F)
for (i in 1:max(DF$ID)) {
d <- DF[ which(DF$ID == i),]
LetsGO[i,"Temp"] <- d$Temp[1]
}
LetsGO["Temp"]
TempPlot <- ggplot(data = LetsGO) +
aes(x = Bestmodel, fill = Temp)+
geom_bar()+
scale_fill_viridis(discrete = T)+
theme_minimal()+
theme(legend.position = 'bottom')+
xlab('Model')+
ylab('Count')
TempPlot
# clear any existing graphs and plot your graph within the R window
fern2 <- function(start_position, direction, length, dir)  {
if (length > 0.01) {
x <- start_position
y <- direction
z <-  length
new_start <- turtle(c(x[1], x[2]), y , z)
dir <- dir * -1 # force switch between 1 and -1
fern2(c(new_start[1], new_start[2]), y ,  (z*0.87), dir)
if (dir == -1) {# if dir = -1 direction goes left
fern2(c(new_start[1], new_start[2]), y + (pi/4),  (z*0.38), dir * -1)
}else if (dir == 1) {# if dir = 1 direction goes right
fern2(c(new_start[1], new_start[2]), y - (pi/4),  (z*0.38), dir)
}
}
}
graphics.off()# clear any existing graphs and plot your graph within the R window
tempplot <-plot(1, type = "n",                         # Remove all elements of plot
xlab = "", ylab = "",
xlim = c(-15, 15), ylim = c(-15, 15))
tic()
fern2(start_position = c(0, -15), direction =pi/2, length = 4, dir = 1)# dir starts= 1 to force direction to go left first
toc()
library(tictoc)
tic()
fern2(start_position = c(0, -15), direction =pi/2, length = 4, dir = 1)# dir starts= 1 to force direction to go left first
toc()
fern2(start_position = c(0, -15), direction =pi/2, length = 4, dir = 1)# dir starts= 1 to force direction to go left first
source("~/CMEECourseWork/HPC/fc420/fc420_HPC_2021_main.R", echo=TRUE)
tic()
fern2(start_position = c(0, -15), direction =pi/2, length = 4, dir = 1)# dir starts= 1 to force direction to go left first
toc()
par(2,2)
par(c(2,2))
graphics.off()# clear any existing graphs and plot your graph within the R window
par(mfrow=c(2,2))
tempplot <-plot(1, type = "n",                         # Remove all elements of plot
xlab = "", ylab = "",
xlim = c(-15, 15), ylim = c(-15, 15))
tic()
Standardfern2(start_position = c(0, -15), direction =pi/2, length = 4, dir = 1)# dir starts= 1 to force direction to go left first
toc()
Standardfern2 <- function(start_position, direction, length, dir)  {
if (length > 0.01) {
x <- start_position
y <- direction
z <-  length
new_start <- turtle(c(x[1], x[2]), y , z)
dir <- dir * -1 # force switch between 1 and -1
Standardfern2(c(new_start[1], new_start[2]), y ,  (z*0.87), dir)
if (dir == -1) {# if dir = -1 direction goes left
Standardfern2(c(new_start[1], new_start[2]), y + (pi/4),  (z*0.38), dir * -1)
}else if (dir == 1) {# if dir = 1 direction goes right
Standardfern2(c(new_start[1], new_start[2]), y - (pi/4),  (z*0.38), dir)
}
}
}
graphics.off()# clear any existing graphs and plot your graph within the R window
par(mfrow=c(2,2))
tempplot <-plot(1, type = "n",                         # Remove all elements of plot
xlab = "", ylab = "",
xlim = c(-15, 15), ylim = c(-15, 15))
tic()
Standardfern2(start_position = c(0, -15), direction =pi/2, length = 4, dir = 1)# dir starts= 1 to force direction to go left first
toc()
Shortfern2 <- function(start_position, direction, length, dir)  {
if (length > 0.05) {
x <- start_position
y <- direction
z <-  length
new_start <- turtle(c(x[1], x[2]), y , z)
dir <- dir * -1 # force switch between 1 and -1
Shortfern2(c(new_start[1], new_start[2]), y ,  (z*0.87), dir)
if (dir == -1) {# if dir = -1 direction goes left
Shortfern2(c(new_start[1], new_start[2]), y + (pi/4),  (z*0.38), dir * -1)
}else if (dir == 1) {# if dir = 1 direction goes right
Sorttfern2(c(new_start[1], new_start[2]), y - (pi/4),  (z*0.38), dir)
}
}
}
tic()
Shorfern2(start_position = c(0, -15), direction =pi/2, length = 4, dir = 1)
toc()
tic()
Shortfern2(start_position = c(0, -15), direction =pi/2, length = 4, dir = 1)
toc()
tic()
Shortfern2(start_position = c(0, -15), direction =pi/2, length = 4, dir = 1)
toc()
Shortfern2 <- function(start_position, direction, length, dir)  {
if (length > 0.05) {
x <- start_position
y <- direction
z <-  length
new_start <- turtle(c(x[1], x[2]), y , z)
dir <- dir * -1 # force switch between 1 and -1
Shortfern2(c(new_start[1], new_start[2]), y ,  (z*0.87), dir)
if (dir == -1) {# if dir = -1 direction goes left
Shortfern2(c(new_start[1], new_start[2]), y + (pi/4),  (z*0.38), dir * -1)
}else if (dir == 1) {# if dir = 1 direction goes right
Shortfern2(c(new_start[1], new_start[2]), y - (pi/4),  (z*0.38), dir)
}
}
}
tic()
Shortfern2(start_position = c(0, -15), direction =pi/2, length = 4, dir = 1)
toc()
graphics.off()# clear any existing graphs and plot your graph within the R window
par(mfrow=c(2,2))
tempplot <-plot(1, type = "n",                         # Remove all elements of plot
xlab = "", ylab = "",
xlim = c(-15, 15), ylim = c(-15, 15))
tic()
Standardfern2(start_position = c(0, -15), direction =pi/2, length = 4, dir = 1)# dir starts= 1 to force direction to go left first
toc()
tempplot <-plot(1, type = "n",                         # Remove all elements of plot
xlab = "", ylab = "",
xlim = c(-15, 15), ylim = c(-15, 15))
tic()
Shortfern2(start_position = c(0, -15), direction =pi/2, length = 4, dir = 1)
toc()
Longfern2 <- function(start_position, direction, length, dir)  {
if (length > 0.005) {
x <- start_position
y <- direction
z <-  length
new_start <- turtle(c(x[1], x[2]), y , z)
dir <- dir * -1 # force switch between 1 and -1
Longfern2(c(new_start[1], new_start[2]), y ,  (z*0.87), dir)
if (dir == -1) {# if dir = -1 direction goes left
Longfern2(c(new_start[1], new_start[2]), y + (pi/4),  (z*0.38), dir * -1)
}else if (dir == 1) {# if dir = 1 direction goes right
Longfern2(c(new_start[1], new_start[2]), y - (pi/4),  (z*0.38), dir)
}
}
}
tempplot <-plot(1, type = "n",                         # Remove all elements of plot
xlab = "", ylab = "",
xlim = c(-15, 15), ylim = c(-15, 15))
tic()
Longfern2(start_position = c(0, -15), direction =pi/2, length = 4, dir = 1)
toc()
tic()
Standardfern2(start_position = c(0, -15), direction =pi/2, length = 4, dir = 1)# dir starts= 1 to force direction to go left first
toc()
tempplot <-plot(1, type = "n",                         # Remove all elements of plot
xlab = "", ylab = "",
xlim = c(-15, 15), ylim = c(-15, 15))
tic()
Shortfern2(start_position = c(0, -15), direction =pi/2, length = 4, dir = 1)
toc()
tempplot <-plot(1, type = "n",                         # Remove all elements of plot
xlab = "", ylab = "",
xlim = c(-15, 15), ylim = c(-15, 15))
tic()
Longfern2(start_position = c(0, -15), direction =pi/2, length = 4, dir = 1)
toc()
source("~/CMEECourseWork/HPC/fc420/fc420_HPC_2021_main.R", echo=TRUE)
Challenge_F()
Challenge_F()
source("~/CMEECourseWork/HPC/fc420/fc420_HPC_2021_main.R", echo=TRUE)
Challenge_F()
graphics.off()# clear any existing graphs and plot your graph within the R window
source("~/CMEECourseWork/HPC/fc420/fc420_HPC_2021_main.R", echo=TRUE)
Challenge_F()
Challengeturtle <- function(start_position, direction, length)  {
end_position<- c((cos(direction)*length) + start_position[1], (sin(direction)*length)+start_position[2]) #work out end position based on length and directio
segments(start_position[1],start_position[2],end_position[1], end_position[2],
col = Colour)#draw a line between start and wnd position
return(end_position) # you should return your endpoint here.
}
Challengeturtle <- function(start_position, direction, length, Colour)  {
end_position<- c((cos(direction)*length) + start_position[1], (sin(direction)*length)+start_position[2]) #work out end position based on length and directio
segments(start_position[1],start_position[2],end_position[1], end_position[2],
col = Colour)#draw a line between start and wnd position
return(end_position) # you should return your endpoint here.
}
Xmassfern2 <- function(start_position, direction, length, dir, Colour)  {
if (length > 0.005) {
x <- start_position
y <- direction
z <-  length
Col <-
new_start <- Challengeturtle(c(x[1], x[2]), y , z, Col)
dir <- dir * -1 # force switch between 1 and -1
Xmassfern2 (c(new_start[1], new_start[2]), y ,  (z*0.87), dir, Colour=c("brown"))
if (dir == -1) {# if dir = -1 direction goes left
Xmassfern2 (c(new_start[1], new_start[2]), y + (pi/4),  (z*0.38), dir * -1, Colour=c("dark green"))
}else if (dir == 1) {# if dir = 1 direction goes right
Xmassfern2 (c(new_start[1], new_start[2]), y - (pi/4),  (z*0.38), dir, Colour = c("red"))
}
}
}
tempplot <-plot(1, type = "n",                         # Remove all elements of plot
xlab = "", ylab = "",
xlim = c(-15, 15), ylim = c(-15, 15),
main ="Long fern line size threshold 0.005")
Xmassfern2(start_position = c(0, -15), direction =pi/2, length = 4, dir = 1)
Challengeturtle <- function(start_position, direction, length, Colour)  {
end_position<- c((cos(direction)*length) + start_position[1], (sin(direction)*length)+start_position[2]) #work out end position based on length and directio
segments(start_position[1],start_position[2],end_position[1], end_position[2],
col = Colour)#draw a line between start and wnd position
return(end_position) # you should return your endpoint here.
}
Xmassfern2 <- function(start_position, direction, length, dir, Colour)  {
if (length > 0.005) {
x <- start_position
y <- direction
z <-  length
Col <- Colour
new_start <- Challengeturtle(c(x[1], x[2]), y , z, Col)
dir <- dir * -1 # force switch between 1 and -1
Xmassfern2 (c(new_start[1], new_start[2]), y ,  (z*0.87), dir, Colour=c("brown"))
if (dir == -1) {# if dir = -1 direction goes left
Xmassfern2 (c(new_start[1], new_start[2]), y + (pi/4),  (z*0.38), dir * -1, Colour=c("dark green"))
}else if (dir == 1) {# if dir = 1 direction goes right
Xmassfern2 (c(new_start[1], new_start[2]), y - (pi/4),  (z*0.38), dir, Colour = c("red"))
}
}
}
Xmassfern2(start_position = c(0, -15), direction =pi/2, length = 4, dir = 1)
Xmassfern2(start_position = c(0, -15), direction =pi/2, length = 4, dir = 1, Colour = "brown")
Challengeturtle <- function(start_position, direction, length, Colour)  {
end_position<- c((cos(direction)*length) + start_position[1], (sin(direction)*length)+start_position[2]) #work out end position based on length and directio
segments(start_position[1],start_position[2],end_position[1], end_position[2],
col = Colour)#draw a line between start and wnd position
return(end_position) # you should return your endpoint here.
}
Xmassfern2 <- function(start_position, direction, length, dir, Colour)  {
if (length > 0.01) {
x <- start_position
y <- direction
z <-  length
Col <- Colour
new_start <- Challengeturtle(c(x[1], x[2]), y , z, Col)
dir <- dir * -1 # force switch between 1 and -1
Xmassfern2 (c(new_start[1], new_start[2]), y ,  (z*0.87), dir, Colour=c("brown"))
if (dir == -1) {# if dir = -1 direction goes left
Xmassfern2 (c(new_start[1], new_start[2]), y + (pi/4),  (z*0.38), dir * -1, Colour=c("dark green"))
}else if (dir == 1) {# if dir = 1 direction goes right
Xmassfern2 (c(new_start[1], new_start[2]), y - (pi/4),  (z*0.38), dir, Colour = c("red"))
}
}
}
graphics.off()# clear any existing graphs and plot your graph within the R window
par(mfrow=c(2,2))
tempplot <-plot(1, type = "n",                         # Remove all elements of plot
xlab = "", ylab = "",
xlim = c(-15, 15), ylim = c(-15, 15),
main ="Standard fern line size threshold 0.01")
Standardfern2(start_position = c(0, -15), direction =pi/2, length = 4, dir = 1)# dir starts= 1 to force direction to go left first
tempplot <-plot(1, type = "n",                         # Remove all elements of plot
xlab = "", ylab = "",
xlim = c(-15, 15), ylim = c(-15, 15),
main ="Short fern line size threshold 0.05")
Shortfern2(start_position = c(0, -15), direction =pi/2, length = 4, dir = 1)
tempplot <-plot(1, type = "n",                         # Remove all elements of plot
xlab = "", ylab = "",
xlim = c(-15, 15), ylim = c(-15, 15),
main ="Long fern line size threshold 0.005")
Longfern2(start_position = c(0, -15), direction =pi/2, length = 4, dir = 1)
tempplot <-plot(1, type = "n",                         # Remove all elements of plot
xlab = "", ylab = "",
xlim = c(-15, 15), ylim = c(-15, 15),
main ="Long fern line size threshold 0.005")
Xmassfern2(start_position = c(0, -15), direction =pi/2, length = 4, dir = 1, Colour = "brown")
source("~/CMEECourseWork/HPC/fc420/fc420_HPC_2021_main.R", echo=TRUE)
tic()
Challenge_F()
toc()
source("~/CMEECourseWork/HPC/fc420/fc420_HPC_2021_main.R", echo=TRUE)
tic()
Challenge_F()
toc()
source("~/CMEECourseWork/HPC/fc420/fc420_HPC_2021_main.R", echo=TRUE)
tic()
Challenge_F()
toc()
source("~/CMEECourseWork/HPC/fc420/fc420_HPC_2021_main.R", echo=TRUE)
rm(list=ls()) # nothing written elsewhere should be needed to make this work
# don't worry about comments for this challenge - the number of characters used will be counted starting from here
G<-function(x,y,z,d){if(z>0.01){n<-turtle(c(x[1],x[2]),y,z)|d<-d*-1|G(c(n[1],n[2]),y,(z*0.87),d)|if(d==-1){G(c(n[1],n[2]),y+(pi/4),(z*0.38),d*-1)}else{G(c(n[1],n[2]),y-(pi/4),(z*0.38),d)}}}
G
G(c(0, -15),pi/2,4,1)
source("~/CMEECourseWork/HPC/fc420/fc420_HPC_2021_challengeG.R", echo=TRUE)
G(c(0, -15),pi/2,4,1)
source("~/CMEECourseWork/HPC/fc420/fc420_HPC_2021_challengeG.R", echo=TRUE)
source("~/CMEECourseWork/HPC/fc420/fc420_HPC_2021_challengeG.R", echo=TRUE)
G(c(0, -15),pi/2,4,1)
source("~/.active-rstudio-document", echo=TRUE)
G(c(0, -15),pi/2,4,1)
source("~/.active-rstudio-document", echo=TRUE)
source("~/CMEECourseWork/HPC/fc420/fc420_HPC_2021_challengeG.R", echo=TRUE)
G(c(0, -15),pi/2,4,1)
source("~/CMEECourseWork/HPC/fc420/fc420_HPC_2021_challengeG.R", echo=TRUE)
G(c(0, -15),pi/2,4,1)
source("~/CMEECourseWork/week3/code/PP_Regress.R", echo=TRUE)
BUILDMAT <- function(nrow, ncol){
mat <- do.call("cbind", lapply(1:ncol, function(x) sample(c(1, rep(0, nrow-1)), nrow, prob =1 )))
return(mat)
}
test1 <- BUILDMAT(11,11)
version
source("~/CMEECourseWork/week3/code/apply1.R", echo=TRUE)
source("~/CMEECourseWork/week3/code/apply2.R", echo=TRUE)
View(M)
source("~/CMEECourseWork/week3/code/boilerplate.R", echo=TRUE)
source("~/CMEECourseWork/week3/code/browse.R", echo=TRUE)
Exponential <- function(N0 = 1, r = 1, generations = 10){
# Runs a simulation of exponential growth
# Returns a vector of length generations
N <- rep(NA, generations)    # Creates a vector of NA
N[1] <- N0
for (t in 2:generations){
N[t] <- N[t-1] * exp(r)
browser()
}
return (N)
}
plot(Exponential(), type="l", main="Exponential growth")
doit <- function(x){
temp_x <- sample(x, replace = TRUE)
if(length(unique(temp_x)) > 30) {#only take mean if sample was sufficient
print(paste("Mean of this sample was:", as.character(mean(temp_x))))
}
else {
stop("Couldn't calculate mean: too few unique values!")
}
}
set.seed(1345)
popn<- rnorm(50)
hist(popn)
lapply(1:15, function(i) doit(popn))
result <- lapply(1:15, function(i) try(doit(popn),F))
class(result)
result
result <- vector("list", 15)
for (i in 1:15) {
result[[i]] <- try(doit(popn), FALSE)
}
source("~/CMEECourseWork/week3/code/Gikro.R", echo=TRUE)
data = read.table(file = paste0(res_Path, res)
}
gpath = "/home/frcovell/Project/sandbox/Perliminary/Par test results/Disp and interact change/Dist1Inter1"
setwd(gpath)
amalgamation_Paths = list.dirs(path = gpath, recursive = TRUE) %>% str_subset(pattern = "AmalgamationLandscape1_") %>% str_subset(pattern = "txt/Results") %>% mixedsort()
library(vegan)
library(tidyverse)
library(raster)
library(gtools)
f<-read.table(file.choose())
f
tail(f)
which(f$V1 == 1976)
h <- which(f$V1 == 1976)
h
max(length(h)
)
gpath = "/home/frcovell/Project/sandbox/Perliminary/Par test results/Disp and interact change/Dist1Inter1"
setwd(gpath)
amalgamation_Paths = list.dirs(path = gpath, recursive = TRUE) %>% str_subset(pattern = "AmalgamationLandscape1_") %>% str_subset(pattern = "txt/Results") %>% mixedsort()
amalgamation_Paths
max(amalgamation_Paths)
max(langth(amalgamation_Paths))
max(length(amalgamation_Paths))
amalgamation_Paths[1]
for (i in 1: max(length(amalgamation_Paths))) {
f <- read.table(paste0(amalgamation_Paths[1], "/totalPopSpec.txt"))
}
f
amalgamation_Paths
gpath = "/home/frcovell/Project/sandbox/Sumplimentary/Dispersal/Dispersal1"
setwd(gpath)
seed = list.dirs(path = gpath, recursive = TRUE) %>% str_subset(pattern = "Seed_") %>% str_subset(pattern = "txt/Results") %>% mixedsort()
seed
amalgamation_Paths = list.dirs(path = gpath, recursive = TRUE) %>% str_subset(pattern = "AmalgamationLandscape1_") %>% str_subset(pattern = "txt/Results") %>% mixedsort()
amalgamation_Paths
seed = list.dirs(path = gpath, recursive = TRUE) %>% str_subset(pattern = "Seed_") %>% str_subset(pattern = "txt/Results") %>% mixedsort()
seed
str_split(seed, pattern = "/")[[1]][9]
which(str_split(seed, pattern = "/")[[1]][9] == "Seed_1")
for (i in 1: max(length(seed))) {
which(str_split(seed, pattern = "/")[[i]][9] == "Seed_1")
}
for (i in 1: max(length(seed))) {
g <- which(str_split(seed, pattern = "/")[[i]][9] == "Seed_1")
}
g
source("~/Project/sandbox/DataAnalysis/DataAnalysis.R", echo=TRUE)
source("~/Project/sandbox/DataAnalysis/DataAnalysis.R", echo=TRUE)
source("~/Project/sandbox/DataAnalysis/DataAnalysis.R", echo=TRUE)
source("~/Project/sandbox/DataAnalysis/DataAnalysis.R", echo=TRUE)
source("~/Project/sandbox/DataAnalysis/DataAnalysis.R", echo=TRUE)
AmatotalPops_SE
source("~/Project/sandbox/DataAnalysis/DataAnalysis.R", echo=TRUE)
gpath = "/home/frcovell/Project/sandbox/Sumplimentary/Dispersal/Dispersal0"
setwd(gpath)
# function
## Function to read in any TNM output from any seed, giving the path and the data you want as input
read_Output = function(res_Path, res) {
if(res == "/totalPop.txt") {
cols = c("g", "n")
} else if(res == "/totalPopSpec.txt") {
cols = c("g", "s", "n")
} else if(res == "/cellPop.txt") {
cols = c("g", "c", "n")
} else if(res == "/cellPopSpec.txt") {
cols = c("g", "c", "s", "n")
} else if(res == "/cellRich.txt") {
cols = c("g", "c", "n")
}
if(res == "/cellPopSpec.txt") {
f <- function(x, pos) subset(x, g == 9976)
data = read_delim_chunked(file = paste0(res_Path, res), delim = " ", col_names = cols, chunk_size = 10000, callback = DataFrameCallback$new(f),
progress = FALSE)
} else {
data = read.table(file = paste0(res_Path, res), col.names = cols)
}
seed = str_split(res_Path, pattern = "/")[[1]][9] %>% str_split(., pattern = "_") %>% simplify() %>% nth(2)
run = str_split(res_Path, pattern = "/")[[1]][11] %>% str_split(., pattern = "_") %>% simplify() %>% nth(2)
patch = str_split(res_Path, pattern = "/")[[1]][12] %>% str_split(., pattern = "_") %>% simplify() %>% nth(2)%>% str_split(., pattern = ".t") %>% simplify() %>% nth(1)
data = data %>% add_column(seed = seed, run = run, patch = patch)
return(data)
}
SE = function(x) {
sample_Size = length(x)
SD = sd(x)
SE = SD/sqrt(sample_Size)
return(SE)
}
amalgamation_Paths = list.dirs(path = gpath, recursive = TRUE) %>% str_subset(pattern = "AmalgamationLandscape1_") %>% str_subset(pattern = "txt/Results") %>% mixedsort()
amalgamation_Paths = append(amalgamation_Paths, list.dirs(path = gpath, recursive = TRUE) %>% str_subset(pattern = "/Landscape1") %>% str_subset(pattern = "txt/Results") %>% mixedsort())
AmatotalPops = mcmapply(read_Output, amalgamation_Paths, "/totalPop.txt", SIMPLIFY = F, mc.cores = 6) %>% bind_rows()
AmatotalPops
amalgamation_Paths
source("~/Project/sandbox/DataAnalysis/DataAnalysis.R", echo=TRUE)
list.dirs(path = gpath, recursive = TRUE) %>% str_subset(pattern = "AmalgamationLandscape1_") %>% str_subset(pattern = "txt/Results") %>% mixedsort()
list.dirs(path = gpath, recursive = TRUE) %>% str_subset(pattern = "AmalgamationLandscape1_") %>% str_subset(pattern = "txt/Results")
list.dirs(path = gpath, recursive = TRUE) %>% str_subset(pattern = "AmalgamationLandscape1_")
source("~/Project/sandbox/DataAnalysis/DataAnalysis.R", echo=TRUE)
source("~/Project/sandbox/DataAnalysis/DataAnalysis.R", echo=TRUE)
source("~/Project/sandbox/DataAnalysis/DataAnalysis.R", echo=TRUE)
source("~/Project/sandbox/DataAnalysis/DataAnalysis.R", echo=TRUE)
gpath = "/home/frcovell/Project/sandbox/Sumplimentary/Interaction/Interaction 1.5"
setwd(gpath)
source("~/Project/sandbox/DataAnalysis/DataAnalysis.R", echo=TRUE)
setwd("../Interaction1.5/")
source("~/Project/sandbox/DataAnalysis/DataAnalysis.R", echo=TRUE)
# function
## Function to read in any TNM output from any seed, giving the path and the data you want as input
read_Output = function(res_Path, res) {
if(res == "/totalPop.txt") {
cols = c("g", "n")
} else if(res == "/totalPopSpec.txt") {
cols = c("g", "s", "n")
} else if(res == "/cellPop.txt") {
cols = c("g", "c", "n")
} else if(res == "/cellPopSpec.txt") {
cols = c("g", "c", "s", "n")
} else if(res == "/cellRich.txt") {
cols = c("g", "c", "n")
}
if(res == "/cellPopSpec.txt") {
f <- function(x, pos) subset(x, g == 9976)
data = read_delim_chunked(file = paste0(res_Path, res), delim = " ", col_names = cols, chunk_size = 10000, callback = DataFrameCallback$new(f),
progress = FALSE)
} else {
data = read.table(file = paste0(res_Path, res), col.names = cols)
}
seed = str_split(res_Path, pattern = "/")[[1]][9] %>% str_split(., pattern = "_") %>% simplify() %>% nth(2)
run = str_split(res_Path, pattern = "/")[[1]][11] %>% str_split(., pattern = "_") %>% simplify() %>% nth(2)
patch = str_split(res_Path, pattern = "/")[[1]][12] %>% str_split(., pattern = "_") %>% simplify() %>% nth(2)%>% str_split(., pattern = ".t") %>% simplify() %>% nth(1)
data = data %>% add_column(seed = seed, run = run, patch = patch)
return(data)
}
SE = function(x) {
sample_Size = length(x)
SD = sd(x)
SE = SD/sqrt(sample_Size)
return(SE)
}
amalgamation_Paths = list.dirs(path = gpath, recursive = TRUE) %>% str_subset(pattern = "AmalgamationLandscape1_") %>% str_subset(pattern = "txt/Results") %>% mixedsort()
amalgamation_Paths = append(amalgamation_Paths, list.dirs(path = gpath, recursive = TRUE) %>% str_subset(pattern = "/Landscape1") %>% str_subset(pattern = "txt/Results") %>% mixedsort())
AmatotalPops = mcmapply(read_Output, amalgamation_Paths, "/totalPop.txt", SIMPLIFY = F, mc.cores = 6) %>% bind_rows()
AmatotalPopSpecs = mcmapply(read_Output, amalgamation_Paths, "/totalPopSpec.txt", SIMPLIFY = F, mc.cores = 6) %>% bind_rows()
AmacellPops = mcmapply(read_Output, amalgamation_Paths, "/cellPop.txt", SIMPLIFY = F, mc.cores = 6) %>% bind_rows()
